# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an Elgato Stream Deck plugin for displaying Azure DevOps information. The plugin is built using the Elgato Stream Deck SDK v2 with TypeScript and follows the official SDK architecture patterns.

## Essential Commands

### Development Commands
```bash
# Build the plugin
npm run build

# Watch mode with auto-restart (restarts Stream Deck plugin on changes)
npm run watch
```

### Testing
The project uses Jest for testing with full test infrastructure:
- Test files are placed alongside source files with `.test.ts` or `.spec.ts` extensions
- Jest is configured in `jest.config.js` with TypeScript support via ts-jest
- Run tests with `npm test` or `npm run test:coverage` for coverage reports
- Mocks are available for Stream Deck SDK modules in `src/__mocks__/`

### Environment Configuration
The project uses a `.env` file for Azure DevOps credentials during development and testing:
- `.env` file contains actual credentials (never committed to version control)
- `.env.example` provides a template with all required variables
- Credentials are loaded using the `dotenv` package
- The `.env` file is properly excluded in `.gitignore`

Required environment variables:
- `AZURE_DEVOPS_ORG_URL`: Your Azure DevOps organization URL
- `AZURE_DEVOPS_PROJECT_NAME`: Project name within the organization
- `AZURE_DEVOPS_PAT`: Personal Access Token for authentication
- `AZURE_DEVOPS_PIPELINE_ID`: Numeric ID of the pipeline to monitor

## Architecture

### Plugin Structure
The Stream Deck plugin follows a specific directory structure:
- **com.sshadows.azure-devops-info.sdPlugin/**: The actual plugin package that Stream Deck loads
  - `manifest.json`: Plugin configuration defining actions, metadata, and entry point
  - `bin/plugin.js`: Compiled JavaScript output (generated by build)
  - `ui/`: HTML files for property inspectors (action configuration UI)
  - `imgs/`: Icons and visual assets for actions and plugin

### Source Code Architecture
- **src/plugin.ts**: Main entry point that:
  - Initializes the Stream Deck connection
  - Registers all actions
  - Sets up logging

- **src/actions/**: Contains action implementations
  - Each action extends `SingletonAction` from the SDK
  - Actions are decorated with `@action` decorator specifying their UUID
  - Actions handle Stream Deck events (onWillAppear, onKeyDown, etc.)

### Build System
- Uses Rollup for bundling TypeScript into a single plugin.js file
- TypeScript configuration extends Node.js 20 base config
- Targets ES2022 modules with Bundler module resolution
- Automatic source maps in watch mode for debugging

### Key Technical Details
- **Node.js Version**: 20 (specified in manifest.json)
- **SDK Version**: 2 (Stream Deck SDK v2)
- **Platform Support**: Windows 10+ and macOS 12+
- **Logging**: Set to TRACE level for development (see src/plugin.ts:6)

## Current Implementation Status

✅ **COMPLETED**: The Azure DevOps pipeline status display is fully functional! The plugin successfully:
- Connects to Azure DevOps using Personal Access Tokens
- Displays real-time pipeline status with visual indicators
- **Branch Filtering**: Monitor specific branches (e.g., main, develop) or all branches
- Shows build information (version, build number, duration)
- Updates automatically at configured intervals (30-300 seconds)
- Supports multiple pipeline states (Success, Failed, Running, Partial, Canceled, Unknown, Not Started)
- Encrypts credentials using AES-256-GCM for secure storage
- Implements caching to minimize API calls
- Handles errors gracefully with retry logic and exponential backoff

### Implemented Components

#### Actions (`src/actions/`)
- **PipelineStatusAction**: Main action that displays pipeline status
  - Polls Azure DevOps at configured intervals
  - Updates Stream Deck button with status, color, and text
  - Opens pipeline in browser on button press
- **PullRequestStatusAction**: Action that displays pull request status and metrics
  - Monitors pull requests across repositories or specific repositories
  - Filters by status, branch, creator, reviewer, and age
  - Displays count, age, titles, and merge conflict indicators

#### Services (`src/services/`)
- **AzureDevOpsClient**: Handles Azure DevOps API authentication and connections
- **PipelineService**: Manages pipeline status retrieval with caching
- **PullRequestService**: Manages pull request retrieval with filtering and aggregation

#### Utilities (`src/utils/`)
- **StatusDisplayManager**: Maps pipeline statuses to colors and formatting
- **PRDisplayManager**: Maps pull request states to colors and formatting
- **CredentialManager**: Encrypts/decrypts PAT tokens for secure storage
- **ErrorHandler**: Comprehensive error handling with retry logic

#### UI (`com.sshadows.azure-devops-info.sdPlugin/ui/`)
- **pipeline-status.html**: Property Inspector for pipeline configuration
- **pull-request-status.html**: Property Inspector for pull request configuration
- **pipeline-status.css**: Styling for pipeline Property Inspector
- **pull-request-status.css**: Styling for pull request Property Inspector

## SDK Documentation References

Key SDK documentation for this project:
- [Getting Started](https://docs.elgato.com/streamdeck/sdk/introduction/getting-started/)
- [Actions Guide](https://docs.elgato.com/streamdeck/sdk/guides/actions)
- [Settings Guide](https://docs.elgato.com/streamdeck/sdk/guides/settings)
- [Manifest Reference](https://docs.elgato.com/streamdeck/sdk/references/manifest)

### Example Plugins
The `streamdeck-plugin-samples` subfolder contains official Elgato Stream Deck plugin examples that demonstrate correct SDK v2 patterns:
- **hello-world**: Basic plugin structure and communication patterns
- **data-sources**: Shows proper Property Inspector to Plugin communication using `streamDeck.ui.current?.sendToPropertyInspector()`
- **counter**: Demonstrates state management and updates
- **cpu**: Shows dynamic data updates and monitoring

These examples are valuable references for:
- Correct SDPIComponents v4 API usage
- Property Inspector communication patterns
- Local `sdpi-components.js` usage (instead of CDN)
- Proper event handling between Plugin and Property Inspector

## Debugging

### Plugin Logs
The plugin writes detailed logs that are essential for debugging:
- **Log location**: `U:\Git\azure-devops-info\com.sshadows.azure-devops-info.sdPlugin\logs\com.sshadows.azure-devops-info.0.log`
- Logs include connection attempts, API calls, error messages, and state changes
- Log level is set to TRACE in development (see src/plugin.ts:6)

### Stream Deck DevTools
Stream Deck provides a Chrome DevTools interface for debugging:
- **DevTools URL**: `http://localhost:23654/`
- Access the inspector for your plugin instance
- View console logs, network requests, and debug Property Inspector communication
- Useful for debugging JavaScript errors and monitoring plugin-to-PI communication

### Common Debugging Commands

#### Windows Commands (PowerShell/CMD)
```bash
# List directory contents
dir "path\to\directory"
# Example: dir "com.sshadows.azure-devops-info.sdPlugin\imgs\actions"

# View file contents
type "path\to\file"
# Example: type "com.sshadows.azure-devops-info.sdPlugin\logs\com.sshadows.azure-devops-info.0.log"

# View last N lines of a file (PowerShell)
powershell -Command "Get-Content 'path\to\file' -Tail 50"
# Example: powershell -Command "Get-Content 'com.sshadows.azure-devops-info.sdPlugin\logs\com.sshadows.azure-devops-info.0.log' -Tail 50"

# Search file contents (PowerShell)
powershell -Command "Get-Content 'path\to\file' | Select-String 'pattern'"
# Example: powershell -Command "Get-Content 'com.sshadows.azure-devops-info.sdPlugin\logs\com.sshadows.azure-devops-info.0.log' | Select-String 'propertyInspector'"

# Search with multiple patterns (PowerShell)
powershell -Command "Get-Content 'path\to\file' | Select-String 'pattern1|pattern2|pattern3'"

# Restart the plugin after making changes
streamdeck restart com.sshadows.azure-devops-info

# Validate plugin structure
streamdeck validate

# Build and watch for changes
npm run watch
```

### Known Issues and Solutions

#### __dirname is not defined
**Problem**: The azure-devops-node-api library uses Node.js globals like `__dirname` which don't exist in the bundled environment.
**Solution**: Added a polyfill in rollup.config.mjs to define `__dirname` globally before the code runs.

#### SDPIComponents v4 API Usage
**Problem**: Property Inspector communication using incorrect API methods like `onConnected()`, `onDidReceiveSettings()`, etc., or trying to use custom JavaScript event handlers.
**Solution**: Use pure SDPI Components patterns following official SDK examples:
- **AVOID custom JavaScript entirely** - use pure SDPI Components markup
- **Data Sources**: Use `datasource="eventName"` attribute for dynamic dropdowns
- **Settings**: Use `setting="settingName"` attribute for automatic synchronization
- **Local Components**: Use local `sdpi-components.js` instead of CDN
- **No Manual Event Handling**: Let SDPI Components handle all communication automatically

#### Property Inspector Debugging Lessons
**Critical Lesson**: When Property Inspector dropdowns aren't populating or JavaScript errors occur, the solution is almost always to simplify and follow official SDK examples more closely:

1. **Remove all custom JavaScript** from Property Inspector HTML files
2. **Use pure SDPI Components markup** with datasource attributes
3. **Study official examples** in `streamdeck-plugin-samples/data-sources/`
4. **Get current settings properly** in action's `onSendToPlugin` method using `await ev.action.getSettings()`
5. **Don't assume `ev.payload.settings` exists** in data source requests - it's often undefined

## Common Stream Deck Plugin Patterns

Based on the official SDK examples, here are the key patterns and best practices:

### 1. Plugin Structure
- **Entry point**: `src/plugin.ts` that registers actions and connects to Stream Deck
- **Actions**: Located in `src/actions/` directory, each extending `SingletonAction`
- **Decorator**: Use `@action` decorator with UUID matching manifest.json
- **Logging**: Enable TRACE logging for development debugging

### 2. Action Lifecycle Methods
- **`onWillAppear`**: Initialize action when it becomes visible on Stream Deck
- **`onWillDisappear`**: Clean up resources when action is removed
- **`onKeyDown/onKeyUp`**: Handle button press events
- **`onDialRotate`**: Handle encoder rotation (Stream Deck +)
- **`onDidReceiveSettings`**: React to Property Inspector setting changes
- **`onSendToPlugin`**: Handle custom messages from Property Inspector

### 3. Property Inspector Communication (CRITICAL PATTERNS)
**IMPORTANT**: Following the official SDK examples is essential for working Property Inspectors.

#### ✅ CORRECT Property Inspector Pattern (Pure SDPI Components)
```html
<!-- Example from working PR Checks implementation -->
<sdpi-select setting="repository" default="all" 
             datasource="getRepositories" 
             loading="Fetching repositories..." 
             placeholder="Please select">
</sdpi-select>
```

#### ❌ AVOID Custom JavaScript Event Handling
```html
<!-- DON'T DO THIS - causes dispatcher errors -->
<script>
streamDeckClient.didReceiveSettings = (settings) => { ... }
streamDeckClient.onConnected = () => { ... }
</script>
```

#### Data Source Communication Flow
1. **Property Inspector**: Use `datasource="getRepositories"` attribute
2. **SDPI Components**: Automatically sends `{event: "getRepositories"}` to plugin
3. **Action's onSendToPlugin**: Handle the event and get current settings:
   ```typescript
   override async onSendToPlugin(ev: SendToPluginEvent<JsonValue, Settings>): Promise<void> {
       if (ev.payload instanceof Object && "event" in ev.payload && ev.payload.event === "getRepositories") {
           // CRITICAL: Get settings from action, NOT from ev.payload.settings (which is undefined)
           const currentSettings = await ev.action.getSettings();
           await this.sendRepositoryList(ev.action, currentSettings);
       }
   }
   ```
4. **Plugin Response**: Send data back via `streamDeck.ui.current?.sendToPropertyInspector()`
5. **SDPI Components**: Automatically populates dropdown with returned data

#### Settings Access Patterns
- **In Property Inspector**: Use `setting="settingName"` attribute for automatic sync
- **In Action Methods**: 
  - ✅ Use `ev.payload.settings` for settings events (`onDidReceiveSettings`)
  - ✅ Use `await ev.action.getSettings()` for data source requests (`onSendToPlugin`)
  - ❌ NEVER assume `ev.payload.settings` exists in `onSendToPlugin` events

### 4. Common Implementation Patterns
- **Settings Management**: 
  - Define typed settings interfaces
  - Use `ev.action.setSettings()` to save settings
  - Use `ev.action.getSettings()` to retrieve current settings
- **Visual Updates**: 
  - `action.setTitle()` - Update button text
  - `action.setImage()` - Update button image
  - `action.setState()` - Toggle button states
- **Feedback Layouts**: 
  - `action.setFeedbackLayout()` for Stream Deck + encoder displays
  - `action.setFeedback()` to update layout values
- **Error Handling**: 
  - Wrap async operations in try-catch blocks
  - Use `streamDeck.logger.error()` for logging errors
- **Timers**: 
  - Store interval/timeout references for cleanup
  - Clear timers in `onWillDisappear` to prevent memory leaks

### 5. Critical Anti-Patterns and Solutions

#### **NEVER Call `action.getSettings()` in Settings Handlers**
**❌ WRONG - Creates Infinite Feedback Loop:**
```typescript
override async onDidReceiveSettings(ev: DidReceiveSettingsEvent<Settings>): Promise<void> {
    const oldSettings = await ev.action.getSettings(); // ❌ This triggers another didReceiveSettings!
    // ... rest of handler
}
```

**✅ CORRECT - Store Settings in Local State:**
```typescript
private settingsDebounceTimeouts = new Map<string, NodeJS.Timeout>();

override async onDidReceiveSettings(ev: DidReceiveSettingsEvent<Settings>): Promise<void> {
    // Debounce rapid settings changes
    const existingTimeout = this.settingsDebounceTimeouts.get(ev.action.id);
    if (existingTimeout) clearTimeout(existingTimeout);
    
    const timeout = setTimeout(async () => {
        await this.processSettingsChange(ev.action.id, ev.payload.settings);
        this.settingsDebounceTimeouts.delete(ev.action.id);
    }, 500);
    
    this.settingsDebounceTimeouts.set(ev.action.id, timeout);
}

private async processSettingsChange(actionId: string, settings: Settings): Promise<void> {
    // Get old settings from local state, NOT from action.getSettings()
    const state = this.stateManager.getState(actionId);
    const oldSettings = state.lastSettings as Settings || {};
    
    // Store new settings for future reference
    state.lastSettings = settings;
    
    // Process the settings change...
}
```

**Why This Happens**: `action.getSettings()` sends a `getSettings` event to Stream Deck, which responds with `didReceiveSettings`, creating an infinite loop.

**Store Settings On**: 
- `onWillAppear`: `state.lastSettings = ev.payload.settings`
- `processSettingsChange`: `state.lastSettings = settings`

#### **Always Debounce Settings Changes**
Users typing in Property Inspector fields generate rapid `didReceiveSettings` events. Always use debouncing:

```typescript
// ✅ Debounce with 500ms timeout to prevent rapid-fire processing
const timeout = setTimeout(async () => {
    await this.processSettingsChange(actionId, settings);
}, 500);
```

#### **Use State Manager for ActionState.lastSettings**
Add to your ActionState interface:
```typescript
export interface ActionState {
    // ... other properties
    lastSettings?: any; // Store last settings to avoid getSettings() feedback loops
}
```

### 6. Best Practices
- **Type Guards**: Use `isKey()` before key-specific operations
- **Singleton Pattern**: Share state across multiple action instances
- **Action References**: Store action instances for batch updates
- **Resource Cleanup**: Always clean up timers/connections in `onWillDisappear`
- **Image Handling**: Use Buffer/base64 encoding for dynamic images
- **Async Operations**: Return promises from lifecycle methods for proper sequencing
- **Settings Debouncing**: Always debounce `onDidReceiveSettings` to prevent rapid processing
- **Local State Storage**: Store settings in ActionState instead of calling `action.getSettings()`