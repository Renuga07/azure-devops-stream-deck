# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an Elgato Stream Deck plugin for displaying Azure DevOps information. The plugin is built using the Elgato Stream Deck SDK v2 with TypeScript and follows the official SDK architecture patterns.

## Essential Commands

### Development Commands
```bash
# Build the plugin
npm run build

# Watch mode with auto-restart (restarts Stream Deck plugin on changes)
npm run watch
```

### Testing
The project uses Jest for testing with full test infrastructure:
- Test files are placed alongside source files with `.test.ts` or `.spec.ts` extensions
- Jest is configured in `jest.config.js` with TypeScript support via ts-jest
- Run tests with `npm test` or `npm run test:coverage` for coverage reports
- Mocks are available for Stream Deck SDK modules in `src/__mocks__/`

### Environment Configuration
The project uses a `.env` file for Azure DevOps credentials during development and testing:
- `.env` file contains actual credentials (never committed to version control)
- `.env.example` provides a template with all required variables
- Credentials are loaded using the `dotenv` package
- The `.env` file is properly excluded in `.gitignore`

Required environment variables:
- `AZURE_DEVOPS_ORG_URL`: Your Azure DevOps organization URL
- `AZURE_DEVOPS_PROJECT_NAME`: Project name within the organization
- `AZURE_DEVOPS_PAT`: Personal Access Token for authentication
- `AZURE_DEVOPS_PIPELINE_ID`: Numeric ID of the pipeline to monitor

## Architecture

### Plugin Structure
The Stream Deck plugin follows a specific directory structure:
- **com.sshadows.azure-devops-info.sdPlugin/**: The actual plugin package that Stream Deck loads
  - `manifest.json`: Plugin configuration defining actions, metadata, and entry point
  - `bin/plugin.js`: Compiled JavaScript output (generated by build)
  - `ui/`: HTML files for property inspectors (action configuration UI)
  - `imgs/`: Icons and visual assets for actions and plugin

### Source Code Architecture
- **src/plugin.ts**: Main entry point that:
  - Initializes the Stream Deck connection
  - Registers all actions
  - Sets up logging

- **src/actions/**: Contains action implementations
  - Each action extends `SingletonAction` from the SDK
  - Actions are decorated with `@action` decorator specifying their UUID
  - Actions handle Stream Deck events (onWillAppear, onKeyDown, etc.)

### Build System
- Uses Rollup for bundling TypeScript into a single plugin.js file
- TypeScript configuration extends Node.js 20 base config
- Targets ES2022 modules with Bundler module resolution
- Automatic source maps in watch mode for debugging

### Key Technical Details
- **Node.js Version**: 20 (specified in manifest.json)
- **SDK Version**: 2 (Stream Deck SDK v2)
- **Platform Support**: Windows 10+ and macOS 12+
- **Logging**: Set to TRACE level for development (see src/plugin.ts:6)

## Current Implementation Status

✅ **COMPLETED**: The Azure DevOps pipeline status display is fully functional! The plugin successfully:
- Connects to Azure DevOps using Personal Access Tokens
- Displays real-time pipeline status with visual indicators
- **Branch Filtering**: Monitor specific branches (e.g., main, develop) or all branches
- Shows build information (version, build number, duration)
- Updates automatically at configured intervals (30-300 seconds)
- Supports multiple pipeline states (Success, Failed, Running, Partial, Canceled, Unknown, Not Started)
- Encrypts credentials using AES-256-GCM for secure storage
- Implements caching to minimize API calls
- Handles errors gracefully with retry logic and exponential backoff

### Implemented Components

#### Actions (`src/actions/`)
- **PipelineStatusAction**: Main action that displays pipeline status
  - Polls Azure DevOps at configured intervals
  - Updates Stream Deck button with status, color, and text
  - Opens pipeline in browser on button press
- **PullRequestStatusAction**: Action that displays pull request status and metrics
  - Monitors pull requests across repositories or specific repositories
  - Filters by status, branch, creator, reviewer, and age
  - Displays count, age, titles, and merge conflict indicators

#### Services (`src/services/`)
- **AzureDevOpsClient**: Handles Azure DevOps API authentication and connections
- **PipelineService**: Manages pipeline status retrieval with caching
- **PullRequestService**: Manages pull request retrieval with filtering and aggregation

#### Utilities (`src/utils/`)
- **StatusDisplayManager**: Maps pipeline statuses to colors and formatting
- **PRDisplayManager**: Maps pull request states to colors and formatting
- **CredentialManager**: Encrypts/decrypts PAT tokens for secure storage
- **ErrorHandler**: Comprehensive error handling with retry logic

#### UI (`com.sshadows.azure-devops-info.sdPlugin/ui/`)
- **pipeline-status.html**: Property Inspector for pipeline configuration
- **pull-request-status.html**: Property Inspector for pull request configuration
- **pipeline-status.css**: Styling for pipeline Property Inspector
- **pull-request-status.css**: Styling for pull request Property Inspector

## SDK Documentation References

Key SDK documentation for this project:
- [Getting Started](https://docs.elgato.com/streamdeck/sdk/introduction/getting-started/)
- [Actions Guide](https://docs.elgato.com/streamdeck/sdk/guides/actions)
- [Settings Guide](https://docs.elgato.com/streamdeck/sdk/guides/settings)
- [Manifest Reference](https://docs.elgato.com/streamdeck/sdk/references/manifest)

### Example Plugins
The `streamdeck-plugin-samples` subfolder contains official Elgato Stream Deck plugin examples that demonstrate correct SDK v2 patterns:
- **hello-world**: Basic plugin structure and communication patterns
- **data-sources**: Shows proper Property Inspector to Plugin communication using `streamDeck.ui.current?.sendToPropertyInspector()`
- **counter**: Demonstrates state management and updates
- **cpu**: Shows dynamic data updates and monitoring

These examples are valuable references for:
- Correct SDPIComponents v4 API usage
- Property Inspector communication patterns
- Local `sdpi-components.js` usage (instead of CDN)
- Proper event handling between Plugin and Property Inspector

## Debugging

### Plugin Logs
The plugin writes detailed logs that are essential for debugging:
- **Log location**: `U:\Git\azure-devops-info\com.sshadows.azure-devops-info.sdPlugin\logs\com.sshadows.azure-devops-info.0.log`
- Logs include connection attempts, API calls, error messages, and state changes
- Log level is set to TRACE in development (see src/plugin.ts:6)

### Stream Deck DevTools
Stream Deck provides a Chrome DevTools interface for debugging:
- **DevTools URL**: `http://localhost:23654/`
- Access the inspector for your plugin instance
- View console logs, network requests, and debug Property Inspector communication
- Useful for debugging JavaScript errors and monitoring plugin-to-PI communication

### Common Debugging Commands

#### Windows Commands (PowerShell/CMD)
```bash
# List directory contents
dir "path\to\directory"
# Example: dir "com.sshadows.azure-devops-info.sdPlugin\imgs\actions"

# View file contents
type "path\to\file"
# Example: type "com.sshadows.azure-devops-info.sdPlugin\logs\com.sshadows.azure-devops-info.0.log"

# View last N lines of a file (PowerShell)
powershell -Command "Get-Content 'path\to\file' -Tail 50"
# Example: powershell -Command "Get-Content 'com.sshadows.azure-devops-info.sdPlugin\logs\com.sshadows.azure-devops-info.0.log' -Tail 50"

# Search file contents (PowerShell)
powershell -Command "Get-Content 'path\to\file' | Select-String 'pattern'"
# Example: powershell -Command "Get-Content 'com.sshadows.azure-devops-info.sdPlugin\logs\com.sshadows.azure-devops-info.0.log' | Select-String 'propertyInspector'"

# Search with multiple patterns (PowerShell)
powershell -Command "Get-Content 'path\to\file' | Select-String 'pattern1|pattern2|pattern3'"

# Restart the plugin after making changes
streamdeck restart com.sshadows.azure-devops-info

# Validate plugin structure
streamdeck validate

# Build and watch for changes
npm run watch
```

### Known Issues and Solutions

#### __dirname is not defined
**Problem**: The azure-devops-node-api library uses Node.js globals like `__dirname` which don't exist in the bundled environment.
**Solution**: Added a polyfill in rollup.config.mjs to define `__dirname` globally before the code runs.

#### SDPIComponents v4 API Usage
**Problem**: Property Inspector communication using incorrect API methods like `onConnected()`, `onDidReceiveSettings()`, etc., or trying to use custom JavaScript event handlers.
**Solution**: Use pure SDPI Components patterns following official SDK examples:
- **AVOID custom JavaScript entirely** - use pure SDPI Components markup
- **Data Sources**: Use `datasource="eventName"` attribute for dynamic dropdowns
- **Settings**: Use `setting="settingName"` attribute for automatic synchronization
- **Local Components**: Use local `sdpi-components.js` instead of CDN
- **No Manual Event Handling**: Let SDPI Components handle all communication automatically

#### Property Inspector Debugging Lessons
**Critical Lesson**: When Property Inspector dropdowns aren't populating or JavaScript errors occur, the solution is almost always to simplify and follow official SDK examples more closely:

1. **Remove all custom JavaScript** from Property Inspector HTML files
2. **Use pure SDPI Components markup** with datasource attributes
3. **Study official examples** in `streamdeck-plugin-samples/data-sources/`
4. **Get current settings properly** in action's `onSendToPlugin` method using `await ev.action.getSettings()`
5. **Don't assume `ev.payload.settings` exists** in data source requests - it's often undefined

### CRITICAL FIX: Property Inspector UI Pattern

**Problem**: Many Property Inspector UIs are broken because they use old-style HTML with custom CSS instead of proper SDPI Components.

**Symptoms**:
- Settings UI doesn't render properly
- Dropdowns don't populate
- Settings don't save
- JavaScript errors in Stream Deck DevTools

**Root Causes**:
1. Using old HTML structure with `<div class="sdpi-wrapper">` and custom CSS files
2. Referencing non-existent `sdpi-components.css` 
3. Using inline `onclick` handlers instead of SDPI's built-in patterns
4. Custom JavaScript event handling

**✅ CORRECT Pattern (Pure SDPI Components)**:
```html
<!DOCTYPE html>
<html>
<head lang="en">
    <title>Action Settings</title>
    <meta charset="utf-8" />
    <script src="sdpi-components.js"></script>
</head>
<body>
    <!-- Use SDPI Components directly, no wrapper divs needed -->
    <sdpi-item label="Organization URL">
        <sdpi-textfield setting="orgUrl" placeholder="https://dev.azure.com/yourorg"></sdpi-textfield>
    </sdpi-item>
    
    <sdpi-item label="Repository">
        <sdpi-select setting="repository" datasource="getRepositories" placeholder="Select repository"></sdpi-select>
    </sdpi-item>
    
    <sdpi-item label="">
        <sdpi-button value="Test Connection" onclick="$pi.sendToPlugin({event: 'testConnection'})"></sdpi-button>
    </sdpi-item>
    
    <sdpi-heading>Display Settings</sdpi-heading>
    
    <sdpi-item label="Mode">
        <sdpi-select setting="mode" default="simple">
            <option value="simple">Simple</option>
            <option value="detailed">Detailed</option>
        </sdpi-select>
    </sdpi-item>
</body>
</html>
```

**❌ INCORRECT Pattern (Old Style)**:
```html
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="sdpi-components.css"> <!-- This file doesn't exist! -->
    <link rel="stylesheet" href="custom.css">
</head>
<body>
    <div class="sdpi-wrapper"> <!-- Don't use wrapper divs -->
        <div class="sdpi-item">
            <div class="sdpi-item-label">Organization URL</div>
            <input class="sdpi-item-value" type="text" setting="orgUrl"> <!-- Wrong! -->
        </div>
        <button onclick="window.streamDeckClient?.send('test', {})"> <!-- Wrong event handling -->
    </div>
</body>
</html>
```

**Fix Checklist**:
1. ✅ Include only `sdpi-components.js` script (no CSS files)
2. ✅ Use SDPI component tags directly (`<sdpi-item>`, `<sdpi-textfield>`, etc.)
3. ✅ Remove all wrapper divs and custom classes
4. ✅ Use `$pi.sendToPlugin()` for button events
5. ✅ Delete any custom CSS files for the Property Inspector
6. ✅ Use `datasource` attribute for dynamic dropdowns
7. ✅ Keep HTML minimal - let SDPI Components handle the UI

## Common Stream Deck Plugin Patterns

Based on the official SDK examples, here are the key patterns and best practices:

### 1. Plugin Structure
- **Entry point**: `src/plugin.ts` that registers actions and connects to Stream Deck
- **Actions**: Located in `src/actions/` directory, each extending `SingletonAction`
- **Decorator**: Use `@action` decorator with UUID matching manifest.json
- **Logging**: Enable TRACE logging for development debugging

### 2. Action Lifecycle Methods
- **`onWillAppear`**: Initialize action when it becomes visible on Stream Deck
- **`onWillDisappear`**: Clean up resources when action is removed
- **`onKeyDown/onKeyUp`**: Handle button press events
- **`onDialRotate`**: Handle encoder rotation (Stream Deck +)
- **`onDidReceiveSettings`**: React to Property Inspector setting changes
- **`onSendToPlugin`**: Handle custom messages from Property Inspector

### 3. Property Inspector Communication (CRITICAL PATTERNS)
**IMPORTANT**: Following the official SDK examples is essential for working Property Inspectors.

#### ✅ CORRECT Property Inspector Pattern (Pure SDPI Components)
```html
<!-- Example from working PR Checks implementation -->
<sdpi-select setting="repository" default="all" 
             datasource="getRepositories" 
             loading="Fetching repositories..." 
             placeholder="Please select">
</sdpi-select>
```

#### ❌ AVOID Custom JavaScript Event Handling
```html
<!-- DON'T DO THIS - causes dispatcher errors -->
<script>
streamDeckClient.didReceiveSettings = (settings) => { ... }
streamDeckClient.onConnected = () => { ... }
</script>
```

#### Data Source Communication Flow
1. **Property Inspector**: Use `datasource="getRepositories"` attribute
2. **SDPI Components**: Automatically sends `{event: "getRepositories"}` to plugin
3. **Action's onSendToPlugin**: Handle the event and get current settings:
   ```typescript
   override async onSendToPlugin(ev: SendToPluginEvent<JsonValue, Settings>): Promise<void> {
       if (ev.payload instanceof Object && "event" in ev.payload && ev.payload.event === "getRepositories") {
           // CRITICAL: Get settings from action, NOT from ev.payload.settings (which is undefined)
           const currentSettings = await ev.action.getSettings();
           await this.sendRepositoryList(ev.action, currentSettings);
       }
   }
   ```
4. **Plugin Response**: Send data back via `streamDeck.ui.current?.sendToPropertyInspector()`
5. **SDPI Components**: Automatically populates dropdown with returned data

#### Settings Access Patterns
- **In Property Inspector**: Use `setting="settingName"` attribute for automatic sync
- **In Action Methods**: 
  - ✅ Use `ev.payload.settings` for settings events (`onDidReceiveSettings`)
  - ✅ Use `await ev.action.getSettings()` for data source requests (`onSendToPlugin`)
  - ❌ NEVER assume `ev.payload.settings` exists in `onSendToPlugin` events

### 4. Common Implementation Patterns
- **Settings Management**: 
  - Define typed settings interfaces
  - Use `ev.action.setSettings()` to save settings
  - Use `ev.action.getSettings()` to retrieve current settings
- **Visual Updates**: 
  - `action.setTitle()` - Update button text
  - `action.setImage()` - Update button image
  - `action.setState()` - Toggle button states
- **Feedback Layouts**: 
  - `action.setFeedbackLayout()` for Stream Deck + encoder displays
  - `action.setFeedback()` to update layout values
- **Error Handling**: 
  - Wrap async operations in try-catch blocks
  - Use `streamDeck.logger.error()` for logging errors
- **Timers**: 
  - Store interval/timeout references for cleanup
  - Clear timers in `onWillDisappear` to prevent memory leaks

### 5. Critical Anti-Patterns and Solutions

#### **NEVER Call `action.getSettings()` in Settings Handlers**
**❌ WRONG - Creates Infinite Feedback Loop:**
```typescript
override async onDidReceiveSettings(ev: DidReceiveSettingsEvent<Settings>): Promise<void> {
    const oldSettings = await ev.action.getSettings(); // ❌ This triggers another didReceiveSettings!
    // ... rest of handler
}
```

**✅ CORRECT - Store Settings in Local State:**
```typescript
private settingsDebounceTimeouts = new Map<string, NodeJS.Timeout>();

override async onDidReceiveSettings(ev: DidReceiveSettingsEvent<Settings>): Promise<void> {
    // Debounce rapid settings changes
    const existingTimeout = this.settingsDebounceTimeouts.get(ev.action.id);
    if (existingTimeout) clearTimeout(existingTimeout);
    
    const timeout = setTimeout(async () => {
        await this.processSettingsChange(ev.action.id, ev.payload.settings);
        this.settingsDebounceTimeouts.delete(ev.action.id);
    }, 500);
    
    this.settingsDebounceTimeouts.set(ev.action.id, timeout);
}

private async processSettingsChange(actionId: string, settings: Settings): Promise<void> {
    // Get old settings from local state, NOT from action.getSettings()
    const state = this.stateManager.getState(actionId);
    const oldSettings = state.lastSettings as Settings || {};
    
    // Store new settings for future reference
    state.lastSettings = settings;
    
    // Process the settings change...
}
```

**Why This Happens**: `action.getSettings()` sends a `getSettings` event to Stream Deck, which responds with `didReceiveSettings`, creating an infinite loop.

**Store Settings On**: 
- `onWillAppear`: `state.lastSettings = ev.payload.settings`
- `processSettingsChange`: `state.lastSettings = settings`

#### **Always Debounce Settings Changes**
Users typing in Property Inspector fields generate rapid `didReceiveSettings` events. Always use debouncing:

```typescript
// ✅ Debounce with 500ms timeout to prevent rapid-fire processing
const timeout = setTimeout(async () => {
    await this.processSettingsChange(actionId, settings);
}, 500);
```

#### **Use State Manager for ActionState.lastSettings**
Add to your ActionState interface:
```typescript
export interface ActionState {
    // ... other properties
    lastSettings?: any; // Store last settings to avoid getSettings() feedback loops
}
```

### 6. Best Practices
- **Type Guards**: Use `isKey()` before key-specific operations
- **Singleton Pattern**: Share state across multiple action instances
- **Action References**: Store action instances for batch updates
- **Resource Cleanup**: Always clean up timers/connections in `onWillDisappear`
- **Image Handling**: Use Buffer/base64 encoding for dynamic images
- **Async Operations**: Return promises from lifecycle methods for proper sequencing
- **Settings Debouncing**: Always debounce `onDidReceiveSettings` to prevent rapid processing
- **Local State Storage**: Store settings in ActionState instead of calling `action.getSettings()`
- **SOLID Principles**: Follow SOLID principles for maintainable, testable code (see section below)

## Code Quality Principles

### SOLID Principles
**We commit to following SOLID principles in all new code to ensure maintainability, testability, and flexibility.**

#### S - Single Responsibility Principle (SRP)
Each class should have only one reason to change.

**✅ Good Example:**
```typescript
// Each service has a single, focused responsibility
class PipelineService {
    // Only responsible for pipeline-related operations
    async getPipelineStatus(id: number) { ... }
}

class CredentialManager {
    // Only responsible for credential encryption/decryption
    encrypt(token: string) { ... }
    decrypt(token: string) { ... }
}
```

**❌ Current Violation:**
```typescript
// Action classes are responsible for BOTH business logic AND creating dependencies
class SprintProgressAction {
    constructor() {
        // Creating dependencies - not its responsibility!
        this.sprintService = new SprintService();
        this.credentialManager = new CredentialManager();
    }
}
```

#### O - Open/Closed Principle (OCP)
Software entities should be open for extension but closed for modification.

**✅ Preferred Pattern:**
```typescript
// Define abstractions that can be extended without modifying existing code
interface IStatusDisplay {
    formatStatus(status: string): string;
}

// Extend through implementation, not modification
class PipelineStatusDisplay implements IStatusDisplay { ... }
class BuildStatusDisplay implements IStatusDisplay { ... }
```

#### L - Liskov Substitution Principle (LSP)
Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.

**✅ Good Practice:**
```typescript
// Any implementation of ISprintService can be used interchangeably
function updateSprintDisplay(service: ISprintService) {
    // Works with any ISprintService implementation
    const metrics = await service.getMetrics();
}
```

#### I - Interface Segregation Principle (ISP)
Clients should not be forced to depend on interfaces they don't use.

**✅ Preferred Pattern:**
```typescript
// Specific, focused interfaces
interface ICredentialReader {
    decrypt(token: string): string;
}

interface ICredentialWriter {
    encrypt(token: string): string;
}

// Classes can implement only what they need
class ReadOnlyCredentialService implements ICredentialReader { ... }
```

#### D - Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules. Both should depend on abstractions.

**❌ Current Problem in Action Classes:**
```typescript
// High-level action depends directly on low-level services
class SprintProgressAction {
    constructor() {
        this.sprintService = new SprintService(); // Direct dependency!
        this.credentialManager = new CredentialManager(); // Direct dependency!
    }
}
```

**✅ Solution - Dependency Injection:**
```typescript
// Define abstractions
interface ISprintService {
    getSprintMetrics(settings: SprintSettings): Promise<SprintMetrics>;
}

interface ICredentialManager {
    decrypt(token: string): string;
    encrypt(token: string): string;
}

// Depend on abstractions, inject dependencies
class SprintProgressAction {
    constructor(
        private sprintService: ISprintService,
        private credentialManager: ICredentialManager,
        private stateManager: IActionStateManager
    ) {
        super();
    }
}

// In production
const action = new SprintProgressAction(
    new SprintService(logger),
    new CredentialManager(logger),
    new ActionStateManager()
);

// In tests - inject mocks
const action = new SprintProgressAction(
    mockSprintService,
    mockCredentialManager,
    mockStateManager
);
```

### Dependency Injection Pattern for New Code

When creating new action classes or services, use constructor injection:

```typescript
// 1. Define interfaces for dependencies
interface IDependency {
    doSomething(): Promise<void>;
}

// 2. Accept dependencies through constructor
class NewAction extends SingletonAction {
    constructor(
        private dependency: IDependency = new DefaultDependency()
    ) {
        super();
    }
}

// 3. This allows for:
// - Easy testing with mocks
// - Swapping implementations
// - Clear dependencies
// - Better separation of concerns
```

### Testing Benefits of SOLID Principles

Following SOLID principles dramatically improves testability:

1. **Mockable Dependencies**: Can inject test doubles instead of real services
2. **Isolated Testing**: Each class can be tested independently
3. **Predictable Behavior**: Clear contracts through interfaces
4. **Maintainable Tests**: Changes to implementations don't break tests

**Example Test with Dependency Injection:**
```typescript
describe('SprintProgressAction', () => {
    it('should decrypt token on initialization', async () => {
        // Arrange - inject mocks
        const mockCredentialManager = {
            decrypt: jest.fn().mockReturnValue('decrypted-token')
        };
        const action = new SprintProgressAction(
            mockSprintService,
            mockCredentialManager,
            mockStateManager
        );
        
        // Act
        await action.onWillAppear(event);
        
        // Assert - mocks are actually called!
        expect(mockCredentialManager.decrypt).toHaveBeenCalledWith('encrypted-token');
    });
});
```

### Migration Strategy for Existing Code

For existing action classes with hardcoded dependencies:

1. **Phase 1**: Add optional constructor parameters (backward compatible)
2. **Phase 2**: Extract interfaces from existing services
3. **Phase 3**: Update tests to use dependency injection
4. **Phase 4**: Refactor creation sites to use proper DI

This ensures gradual migration without breaking existing functionality.